var documenterSearchIndex = {"docs":
[{"location":"","page":"-","title":"-","text":"CliffordAlgebra\norder\nsignature\ndimension\ncharacter\nbasesymbol\n\nMultiVector\n*\n/\n\\\n∧\n∨\n⋅\n⨼\n⨽\n⋆\n×₊\n×₋\n≀\ninv\npolarize\nnorm\nnorm_sqr\nexp\nalgebra\nbaseindices\ncoefficients\nscalar\ngrade\nΛᵏ\nreverse\nconj\ngrin\ndual\neven\nodd\nbasevector\npseudoscalar\nprune\nextend\nvector\nmatrix","category":"page"},{"location":"#CliffordAlgebras.CliffordAlgebra","page":"-","title":"CliffordAlgebras.CliffordAlgebra","text":"CliffordAlgebra\n\nCliffordAlgebra{Np,Nn,Nz,S} is a type that describes a geometric algebra with the signature (Np,Nn,Nz), base symbols S.\n\n\n\n\n\n","category":"type"},{"location":"#CliffordAlgebras.order","page":"-","title":"CliffordAlgebras.order","text":"order(::CliffordAlgebra)\norder(::Type{<:CliffordAlgebra})\n\nReturns the order of the algebra. The order is the sum of the signature.\n\n\n\n\n\n","category":"function"},{"location":"#CliffordAlgebras.signature","page":"-","title":"CliffordAlgebras.signature","text":"signature(::CliffordAlgebra)\nsignature(::Type{<:CliffordAlgebra})\n\nReturns the signature of the algebra.\n\n\n\n\n\n","category":"function"},{"location":"#CliffordAlgebras.dimension","page":"-","title":"CliffordAlgebras.dimension","text":"dimension(::CliffordAlgebra)\ndimension(::Type{<:CliffordAlgebra})\n\nReturns the dimension of the algebra, i.e. the number of coefficients in a general multivector.\n\n\n\n\n\n","category":"function"},{"location":"#CliffordAlgebras.character","page":"-","title":"CliffordAlgebras.character","text":"character(::CliffordAlgebra)\ncharacter(::Type{<:CliffordAlgebra})\n\nReturns the square of the pseudoscalar of the algebra.\n\n\n\n\n\n","category":"function"},{"location":"#CliffordAlgebras.basesymbol","page":"-","title":"CliffordAlgebras.basesymbol","text":"basesymbol(::CliffordAlgebra, n::Integer)\nbasesymbol(::Type{<:CliffordAlgebra}, n::Integer)\n\nReturns the symbol used for the n-th basis multivector of the algebra.\n\n\n\n\n\n","category":"function"},{"location":"#CliffordAlgebras.MultiVector","page":"-","title":"CliffordAlgebras.MultiVector","text":"MultiVector{CA,T,BI}\n\nType for a multivector belonging to the algebra CA<:CliffordAlgbra with vector coefficients of type T. Coefficients are stored using a sparse coding, and only the coefficients of the basis indices stored in the tuple BI are considered.\n\n\n\n\n\n","category":"type"},{"location":"#Base.:*","page":"-","title":"Base.:*","text":"a * b\n\nCalculates the geometric product of two MultiVectors a and b.\n\n\n\n\n\n","category":"function"},{"location":"#Base.:/","page":"-","title":"Base.:/","text":"a / b\n(/)(a::MultiVector{CA}, b::MuliVector{CA}) where CA\n\nCalculates the MultiVector quotient a/b by evaluating a*inv(b).\n\n\n\n\n\n","category":"function"},{"location":"#Base.:\\","page":"-","title":"Base.:\\","text":"b \\ a\n(\\)(b::MultiVector{CA}, b::MuliVector{CA}) where CA\n\nCalculates the MultiVector quotient a/b by evaluating inv(b)*a.\n\n\n\n\n\n","category":"function"},{"location":"#CliffordAlgebras.:∧","page":"-","title":"CliffordAlgebras.:∧","text":"a ∧ b\n\nCalculates the wedge product between two MultiVectors a and b.\n\n\n\n\n\n","category":"function"},{"location":"#CliffordAlgebras.:∨","page":"-","title":"CliffordAlgebras.:∨","text":"a ∨ b\n\nCalculates the vee product of the MultiVectors a and b.\n\n\n\n\n\n","category":"function"},{"location":"#CliffordAlgebras.:⋅","page":"-","title":"CliffordAlgebras.:⋅","text":"a ⋅ b\n\nCalculates the \"fat dot\" product between the MultiVectors a and b.\n\n\n\n\n\n","category":"function"},{"location":"#CliffordAlgebras.:⨼","page":"-","title":"CliffordAlgebras.:⨼","text":"a ⨼ b\n\nCalculates the left contraction of the MultiVectors a and b.\n\n\n\n\n\n","category":"function"},{"location":"#CliffordAlgebras.:⨽","page":"-","title":"CliffordAlgebras.:⨽","text":"a ⨽ b\n\nCalculates the right contraction of the MultiVectors a and b.\n\n\n\n\n\n","category":"function"},{"location":"#CliffordAlgebras.:⋆","page":"-","title":"CliffordAlgebras.:⋆","text":"a ⋆ b\n\nCalculates the scalar product of the MultiVectors a and b.\n\n\n\n\n\n","category":"function"},{"location":"#CliffordAlgebras.:×₊","page":"-","title":"CliffordAlgebras.:×₊","text":"a ×₊ b\n\nCalculates the anti-commutator ab+ba of two MultiVectors a and b.\n\n\n\n\n\n","category":"function"},{"location":"#CliffordAlgebras.:×₋","page":"-","title":"CliffordAlgebras.:×₋","text":"a ×₋ b\n\nCalculates the commutator ab-ba of two MultiVectors a and b.\n\n\n\n\n\n","category":"function"},{"location":"#CliffordAlgebras.:≀","page":"-","title":"CliffordAlgebras.:≀","text":"a ≀ b\n\nCalculates the sandwich product abreverse(a) for two MultiVectors a and b.\n\n\n\n\n\n","category":"function"},{"location":"#Base.inv","page":"-","title":"Base.inv","text":"inv(::MultiVector)\n\nFinds the inverse of the MultiVector. If no inverse exists a SingularException is thrown.\n\n\n\n\n\n","category":"function"},{"location":"#CliffordAlgebras.polarize","page":"-","title":"CliffordAlgebras.polarize","text":"polarize(mv::MultiVector)\nmv'\n\nCalculates the polarization of the MultiVector, i.e. mv * pseudoscalar.\n\n\n\n\n\n","category":"function"},{"location":"#LinearAlgebra.norm","page":"-","title":"LinearAlgebra.norm","text":"norm(::MultiVector)\n\nCalculates the MultiVector norm defined as sqrt(grade(mv*reverse(mv),0))\n\n\n\n\n\n","category":"function"},{"location":"#LinearAlgebra.norm_sqr","page":"-","title":"LinearAlgebra.norm_sqr","text":"norm_sqr(::MultiVector)\n\nCalculates the MultiVector squared norm defined as grade(mv*reverse(mv),0)\n\n\n\n\n\n","category":"function"},{"location":"#Base.exp","page":"-","title":"Base.exp","text":"exp(::MultiVector)\n\nCalculates the exponential function of the MultiVector defined by analytic continuation. The generated code is automaticall specialized for the sparse representation of the MultiVector. It may take advantage of commuting base vectors and split off exponential factors. Hyperbolic, trigonometric and nilpotent solutions are recognized and handled separately. Calling prune or grade before exp may help to find the best algorithm for the exponential evaluation.\n\n\n\n\n\n","category":"function"},{"location":"#CliffordAlgebras.algebra","page":"-","title":"CliffordAlgebras.algebra","text":"algebra(::MultiVector)\nalgebra(::Type{<:MultiVector})\n\nReturns the CliffordAlgebra to which the MultiVector belongs.\n\n\n\n\n\n","category":"function"},{"location":"#CliffordAlgebras.baseindices","page":"-","title":"CliffordAlgebras.baseindices","text":"baseindices(::MultiVector)\nbaseindices(::Type{<:MultiVector})\n\nReturns the indices for the sparse MultiVector basis.\n\n\n\n\n\n","category":"function"},{"location":"#CliffordAlgebras.coefficients","page":"-","title":"CliffordAlgebras.coefficients","text":"coefficients(::MultiVector)\n\nReturns the sparse coefficients of the MultiVector.\n\n\n\n\n\n","category":"function"},{"location":"#CliffordAlgebras.scalar","page":"-","title":"CliffordAlgebras.scalar","text":"scalar(mv::MultiVector)\n\nReturns the scalar component of the multivector. The result if of the internal storage type eltype(mv).\n\n\n\n\n\n","category":"function"},{"location":"#CliffordAlgebras.grade","page":"-","title":"CliffordAlgebras.grade","text":"grade(::MultiVector, k::Integer)\n\nProjects the MultiVector onto the k-vectors.\n\n\n\n\n\n","category":"function"},{"location":"#CliffordAlgebras.Λᵏ","page":"-","title":"CliffordAlgebras.Λᵏ","text":"Λᵏ(::MultiVector, ::Val{k}) where k\nΛᵏ(::MultiVector, k::Integer)\n\nProjects the MultiVector onto k-vectors. Similar to grade(mv,k), but uses @generated code and compile time optimizations.\n\n\n\n\n\n","category":"function"},{"location":"#Base.reverse","page":"-","title":"Base.reverse","text":"reverse(::MultiVector)\n\nReturns the MultiVector that has all the basis vector products reversed.\n\n\n\n\n\n","category":"function"},{"location":"#Base.conj","page":"-","title":"Base.conj","text":"conj(mv::MultiVector)\n\nReturn the conjugate of the MultiVector, i.e. reverse(grin(mv)).\n\n\n\n\n\n","category":"function"},{"location":"#CliffordAlgebras.grin","page":"-","title":"CliffordAlgebras.grin","text":"grin(mv::MultiVector)\n\nReturns the grade involution of the MultiVector, i.e. even(mv) - odd(mv).\n\n\n\n\n\n","category":"function"},{"location":"#CliffordAlgebras.dual","page":"-","title":"CliffordAlgebras.dual","text":"dual(mv::MultiVector)\n\nReturns the Poincaré dual of the MultiVector, such that for all basis MultiVectors mv * dual(mv) = pseudoscalar. Dual is a linear map and the images of other MultiVectors follow from the images of the basis MultiVectors.\n\n\n\n\n\n","category":"function"},{"location":"#CliffordAlgebras.even","page":"-","title":"CliffordAlgebras.even","text":"even(::MultiVector)\n\nReturns the even grade projection of the MultiVector.\n\n\n\n\n\n","category":"function"},{"location":"#CliffordAlgebras.odd","page":"-","title":"CliffordAlgebras.odd","text":"odd(::MultiVector)\n\nReturns the odd grade projection of the MultiVector.\n\n\n\n\n\n","category":"function"},{"location":"#CliffordAlgebras.basevector","page":"-","title":"CliffordAlgebras.basevector","text":"basevector(::CliffordAlgebra, n::Integer)\nbasevector(::Type{<:CliffordAlgebra}, n::Integer)\n\nReturns the n-th basis MultiVector of the given CliffordAlgebra.\n\n\n\n\n\nbasevector(::CliffordAlgebra, name::Symbol)\nbasevector(::Type{<:CliffordAlgebra}, name::Symbol)\n\nReturns the basis MultiVector with the specified name from the given Clifford Algebra.\n\n\n\n\n\n","category":"function"},{"location":"#CliffordAlgebras.pseudoscalar","page":"-","title":"CliffordAlgebras.pseudoscalar","text":"pseudoscalar(::CliffordAlgebra)\npseudoscalar(::Type{<:CliffordAlgebra})\n\nReturns the pseudoscalar of the given algebra.\n\n\n\n\n\n","category":"function"},{"location":"#CliffordAlgebras.prune","page":"-","title":"CliffordAlgebras.prune","text":"prune(::MultiVector ; rtol = 1e-8 )\n\nReturns a new MultiVector with all basis vectors removed from the sparse basis whose coefficients fall below the relative magnitude threshold. This function is not type stable, because the return type depends on the sparse basis.\n\n\n\n\n\n","category":"function"},{"location":"#CliffordAlgebras.extend","page":"-","title":"CliffordAlgebras.extend","text":"extend(::MultiVector)\n\nReturns a new MultiVector with a non-sparse coefficient coding. This can be useful to manage type stability.\n\n\n\n\n\n","category":"function"},{"location":"#CliffordAlgebras.vector","page":"-","title":"CliffordAlgebras.vector","text":"vector(::MultiVector)\n\nReturns the non-sparse vector representation of the MutliVector.\n\n\n\n\n\n","category":"function"},{"location":"#CliffordAlgebras.matrix","page":"-","title":"CliffordAlgebras.matrix","text":"matrix(::MultiVector)\n\nReturns the matrix algebra representation of the MultiVector.\n\n\n\n\n\n","category":"function"}]
}
