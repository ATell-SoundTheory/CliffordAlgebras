<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>- · CliffordAlgebras.jl Documentation</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>CliffordAlgebras.jl Documentation</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>-</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>-</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>-</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><p>Exported symbols from <code>CliffordAlgebras.jl</code>:</p><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{CA}, Tuple{MultiVector, MultiVector}} where CA" href="#Base.:*-Union{Tuple{CA}, Tuple{MultiVector, MultiVector}} where CA"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">a * b</code></pre><p>Calculates the geometric product of two MultiVectors a and b.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/arithmetic.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:/-Union{Tuple{CA}, Tuple{MultiVector{CA, T, BI, K} where {T, BI, K}, MultiVector{CA, T, BI, K} where {T, BI, K}}} where CA" href="#Base.:/-Union{Tuple{CA}, Tuple{MultiVector{CA, T, BI, K} where {T, BI, K}, MultiVector{CA, T, BI, K} where {T, BI, K}}} where CA"><code>Base.:/</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">a / b
(/)(a::MultiVector{CA}, b::MuliVector{CA}) where CA</code></pre><p>Calculates the MultiVector quotient a/b by evaluating a*inv(b).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/arithmetic.jl#L408-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:\\-Union{Tuple{CA}, Tuple{MultiVector{CA, T, BI, K} where {T, BI, K}, MultiVector{CA, T, BI, K} where {T, BI, K}}} where CA" href="#Base.:\\-Union{Tuple{CA}, Tuple{MultiVector{CA, T, BI, K} where {T, BI, K}, MultiVector{CA, T, BI, K} where {T, BI, K}}} where CA"><code>Base.:\</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">b \ a
(\)(b::MultiVector{CA}, b::MuliVector{CA}) where CA</code></pre><p>Calculates the MultiVector quotient a/b by evaluating inv(b)*a.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/arithmetic.jl#L418-L423">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:~-Tuple{MultiVector}" href="#Base.:~-Tuple{MultiVector}"><code>Base.:~</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">~a
(~)(::MultiVector)</code></pre><p>Returns the reversed MultiVector reverse(a).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/multivector.jl#L238-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.conj-Tuple{MultiVector}" href="#Base.conj-Tuple{MultiVector}"><code>Base.conj</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conj(mv::MultiVector)</code></pre><p>Return the conjugate of the MultiVector, i.e. reverse(grin(mv)).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/multivector.jl#L247-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.exp-Tuple{MultiVector}" href="#Base.exp-Tuple{MultiVector}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exp(::MultiVector)</code></pre><p>Calculates the exponential function of the MultiVector defined by analytic continuation. The generated code is automaticall specialized for the sparse representation of the MultiVector. It may take advantage of commuting base vectors and split off exponential factors. Hyperbolic, trigonometric and nilpotent solutions are recognized and handled separately. Calling prune or grade before exp may help to find the best algorithm for the exponential evaluation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/arithmetic.jl#L428-L435">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.inv-Tuple{MultiVector}" href="#Base.inv-Tuple{MultiVector}"><code>Base.inv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inv(::MultiVector)</code></pre><p>Finds the inverse of the MultiVector. If no inverse exists a SingularException is thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/arithmetic.jl#L305-L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reverse-Tuple{MultiVector}" href="#Base.reverse-Tuple{MultiVector}"><code>Base.reverse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reverse(::MultiVector)</code></pre><p>Returns the MultiVector that has all the basis vector products reversed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/multivector.jl#L225-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.:×₊-Union{Tuple{Tb}, Tuple{Ta}, Tuple{CA}, Tuple{MultiVector{CA, Ta, BI, K} where {BI, K}, MultiVector{CA, Tb, BI, K} where {BI, K}}} where {CA, Ta, Tb}" href="#CliffordAlgebras.:×₊-Union{Tuple{Tb}, Tuple{Ta}, Tuple{CA}, Tuple{MultiVector{CA, Ta, BI, K} where {BI, K}, MultiVector{CA, Tb, BI, K} where {BI, K}}} where {CA, Ta, Tb}"><code>CliffordAlgebras.:×₊</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">a ×₊ b</code></pre><p>Calculates the anti-commutator ab+ba of two MultiVectors a and b.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/arithmetic.jl#L193-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.:×₋-Union{Tuple{Tb}, Tuple{Ta}, Tuple{CA}, Tuple{MultiVector{CA, Ta, BI, K} where {BI, K}, MultiVector{CA, Tb, BI, K} where {BI, K}}} where {CA, Ta, Tb}" href="#CliffordAlgebras.:×₋-Union{Tuple{Tb}, Tuple{Ta}, Tuple{CA}, Tuple{MultiVector{CA, Ta, BI, K} where {BI, K}, MultiVector{CA, Tb, BI, K} where {BI, K}}} where {CA, Ta, Tb}"><code>CliffordAlgebras.:×₋</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">a ×₋ b</code></pre><p>Calculates the commutator ab-ba of two MultiVectors a and b.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/arithmetic.jl#L181-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.:∧-Union{Tuple{CA}, Tuple{MultiVector{CA, T, BI, K} where {T, BI, K}, MultiVector{CA, T, BI, K} where {T, BI, K}}} where CA" href="#CliffordAlgebras.:∧-Union{Tuple{CA}, Tuple{MultiVector{CA, T, BI, K} where {T, BI, K}, MultiVector{CA, T, BI, K} where {T, BI, K}}} where CA"><code>CliffordAlgebras.:∧</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">a ∧ b</code></pre><p>Calculates the wedge product between two MultiVectors a and b.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/arithmetic.jl#L92-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.:∨-Union{Tuple{CA}, Tuple{MultiVector{CA, T, BI, K} where {T, BI, K}, MultiVector{CA, T, BI, K} where {T, BI, K}}} where CA" href="#CliffordAlgebras.:∨-Union{Tuple{CA}, Tuple{MultiVector{CA, T, BI, K} where {T, BI, K}, MultiVector{CA, T, BI, K} where {T, BI, K}}} where CA"><code>CliffordAlgebras.:∨</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">a ∨ b</code></pre><p>Calculates the vee product of the MultiVectors a and b.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/arithmetic.jl#L132-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.:≀-Union{Tuple{CA}, Tuple{MultiVector{CA, T, BI, K} where {T, BI, K}, MultiVector{CA, T, BI, K} where {T, BI, K}}} where CA" href="#CliffordAlgebras.:≀-Union{Tuple{CA}, Tuple{MultiVector{CA, T, BI, K} where {T, BI, K}, MultiVector{CA, T, BI, K} where {T, BI, K}}} where CA"><code>CliffordAlgebras.:≀</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">a ≀ b</code></pre><p>Calculates the sandwich product a<em>b</em>reverse(a) for two MultiVectors a and b.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/arithmetic.jl#L244-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.:⋅-Union{Tuple{CA}, Tuple{MultiVector{CA, T, BI, K} where {T, BI, K}, MultiVector{CA, T, BI, K} where {T, BI, K}}} where CA" href="#CliffordAlgebras.:⋅-Union{Tuple{CA}, Tuple{MultiVector{CA, T, BI, K} where {T, BI, K}, MultiVector{CA, T, BI, K} where {T, BI, K}}} where CA"><code>CliffordAlgebras.:⋅</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">a ⋅ b</code></pre><p>Calculates the &quot;fat dot&quot; product between the MultiVectors a and b.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/arithmetic.jl#L100-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.:⋆-Union{Tuple{CA}, Tuple{MultiVector{CA, T, BI, K} where {T, BI, K}, MultiVector{CA, T, BI, K} where {T, BI, K}}} where CA" href="#CliffordAlgebras.:⋆-Union{Tuple{CA}, Tuple{MultiVector{CA, T, BI, K} where {T, BI, K}, MultiVector{CA, T, BI, K} where {T, BI, K}}} where CA"><code>CliffordAlgebras.:⋆</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">a ⋆ b</code></pre><p>Calculates the scalar product of the MultiVectors a and b.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/arithmetic.jl#L124-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.:⨼-Union{Tuple{CA}, Tuple{MultiVector{CA, T, BI, K} where {T, BI, K}, MultiVector{CA, T, BI, K} where {T, BI, K}}} where CA" href="#CliffordAlgebras.:⨼-Union{Tuple{CA}, Tuple{MultiVector{CA, T, BI, K} where {T, BI, K}, MultiVector{CA, T, BI, K} where {T, BI, K}}} where CA"><code>CliffordAlgebras.:⨼</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">a ⨼ b</code></pre><p>Calculates the left contraction of the MultiVectors a and b.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/arithmetic.jl#L108-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.:⨽-Union{Tuple{CA}, Tuple{MultiVector{CA, T, BI, K} where {T, BI, K}, MultiVector{CA, T, BI, K} where {T, BI, K}}} where CA" href="#CliffordAlgebras.:⨽-Union{Tuple{CA}, Tuple{MultiVector{CA, T, BI, K} where {T, BI, K}, MultiVector{CA, T, BI, K} where {T, BI, K}}} where CA"><code>CliffordAlgebras.:⨽</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">a ⨽ b</code></pre><p>Calculates the right contraction of the MultiVectors a and b.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/arithmetic.jl#L116-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.algebra-Union{Tuple{Type{var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:(MultiVector{CA, T, BI, K} where {T, BI, K})}, Tuple{CA}} where CA" href="#CliffordAlgebras.algebra-Union{Tuple{Type{var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:(MultiVector{CA, T, BI, K} where {T, BI, K})}, Tuple{CA}} where CA"><code>CliffordAlgebras.algebra</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">algebra(::MultiVector)
algebra(::Type{&lt;:MultiVector})</code></pre><p>Returns the CliffordAlgebra to which the MultiVector belongs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/multivector.jl#L73-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.baseindices-Union{Tuple{Type{var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:(MultiVector{CA, T, BI, K} where K)}, Tuple{BI}, Tuple{T}, Tuple{CA}} where {CA, T, BI}" href="#CliffordAlgebras.baseindices-Union{Tuple{Type{var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:(MultiVector{CA, T, BI, K} where K)}, Tuple{BI}, Tuple{T}, Tuple{CA}} where {CA, T, BI}"><code>CliffordAlgebras.baseindices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">baseindices(::MultiVector)
baseindices(::Type{&lt;:MultiVector})</code></pre><p>Returns the indices for the sparse MultiVector basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/multivector.jl#L87-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.basesymbol-Tuple{Type{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:CliffordAlgebra, Integer}" href="#CliffordAlgebras.basesymbol-Tuple{Type{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:CliffordAlgebra, Integer}"><code>CliffordAlgebras.basesymbol</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basesymbol(::CliffordAlgebra, n::Integer)
basesymbol(::Type{&lt;:CliffordAlgebra}, n::Integer)</code></pre><p>Returns the symbol used for the n-th basis multivector of the algebra.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/algebra.jl#L247-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.basevector-Tuple{Type{var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:CliffordAlgebra, Integer}" href="#CliffordAlgebras.basevector-Tuple{Type{var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:CliffordAlgebra, Integer}"><code>CliffordAlgebras.basevector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basevector(::CliffordAlgebra, n::Integer)
basevector(::Type{&lt;:CliffordAlgebra}, n::Integer)</code></pre><p>Returns the n-th basis MultiVector of the given CliffordAlgebra.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/multivector.jl#L282-L287">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.basevector-Tuple{Type{var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:CliffordAlgebra, Symbol}" href="#CliffordAlgebras.basevector-Tuple{Type{var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:CliffordAlgebra, Symbol}"><code>CliffordAlgebras.basevector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basevector(::CliffordAlgebra, name::Symbol)
basevector(::Type{&lt;:CliffordAlgebra}, name::Symbol)</code></pre><p>Returns the basis MultiVector with the specified name from the given Clifford Algebra.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/multivector.jl#L292-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.character-Tuple{Type{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:CliffordAlgebra}" href="#CliffordAlgebras.character-Tuple{Type{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:CliffordAlgebra}"><code>CliffordAlgebras.character</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">character(::CliffordAlgebra)
character(::Type{&lt;:CliffordAlgebra})</code></pre><p>Returns the square of the pseudoscalar of the algebra.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/algebra.jl#L220-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.coefficients-Tuple{MultiVector}" href="#CliffordAlgebras.coefficients-Tuple{MultiVector}"><code>CliffordAlgebras.coefficients</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coefficients(::MultiVector)</code></pre><p>Returns the sparse coefficients of the MultiVector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/multivector.jl#L65-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.dimension-Tuple{Type{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:CliffordAlgebra}" href="#CliffordAlgebras.dimension-Tuple{Type{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:CliffordAlgebra}"><code>CliffordAlgebras.dimension</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dimension(::CliffordAlgebra)
dimension(::Type{&lt;:CliffordAlgebra})</code></pre><p>Returns the dimension of the algebra, i.e. the number of coefficients in a general multivector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/algebra.jl#L211-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.dual-Union{Tuple{MultiVector{CA, T, BI, K}}, Tuple{K}, Tuple{BI}, Tuple{T}, Tuple{CA}} where {CA, T, BI, K}" href="#CliffordAlgebras.dual-Union{Tuple{MultiVector{CA, T, BI, K}}, Tuple{K}, Tuple{BI}, Tuple{T}, Tuple{CA}} where {CA, T, BI, K}"><code>CliffordAlgebras.dual</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dual(mv::MultiVector)</code></pre><p>Returns the Poincaré dual of the MultiVector, such that for all basis MultiVectors mv * dual(mv) = pseudoscalar. Dual is a linear map and the images of other MultiVectors follow from the images of the basis MultiVectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/multivector.jl#L217-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.even-Tuple{MultiVector}" href="#CliffordAlgebras.even-Tuple{MultiVector}"><code>CliffordAlgebras.even</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">even(::MultiVector)</code></pre><p>Returns the even grade projection of the MultiVector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/multivector.jl#L179-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.extend-Tuple{MultiVector}" href="#CliffordAlgebras.extend-Tuple{MultiVector}"><code>CliffordAlgebras.extend</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extend(::MultiVector)</code></pre><p>Returns a new MultiVector with a non-sparse coefficient coding. This can be useful to manage type stability.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/multivector.jl#L145-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.grade-Tuple{MultiVector, Integer}" href="#CliffordAlgebras.grade-Tuple{MultiVector, Integer}"><code>CliffordAlgebras.grade</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">grade(::MultiVector, k::Integer)</code></pre><p>Projects the MultiVector onto the k-vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/multivector.jl#L164-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.grin-Tuple{MultiVector}" href="#CliffordAlgebras.grin-Tuple{MultiVector}"><code>CliffordAlgebras.grin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">grin(mv::MultiVector)</code></pre><p>Returns the grade involution of the MultiVector, i.e. even(mv) - odd(mv).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/multivector.jl#L210-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.matrix-Tuple{MultiVector}" href="#CliffordAlgebras.matrix-Tuple{MultiVector}"><code>CliffordAlgebras.matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matrix(::MultiVector)</code></pre><p>Returns the matrix algebra representation of the MultiVector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/multivector.jl#L339-L343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.odd-Tuple{MultiVector}" href="#CliffordAlgebras.odd-Tuple{MultiVector}"><code>CliffordAlgebras.odd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">odd(::MultiVector)</code></pre><p>Returns the odd grade projection of the MultiVector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/multivector.jl#L195-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.order-Union{Tuple{Type{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:(CliffordAlgebra{Np, Nn, Nz, S, BT, MT} where {S, BT, MT})}, Tuple{Nz}, Tuple{Nn}, Tuple{Np}} where {Np, Nn, Nz}" href="#CliffordAlgebras.order-Union{Tuple{Type{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:(CliffordAlgebra{Np, Nn, Nz, S, BT, MT} where {S, BT, MT})}, Tuple{Nz}, Tuple{Nn}, Tuple{Np}} where {Np, Nn, Nz}"><code>CliffordAlgebras.order</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">order(::CliffordAlgebra)
order(::Type{&lt;:CliffordAlgebra})</code></pre><p>Returns the order of the algebra. The order is the sum of the signature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/algebra.jl#L174-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.polarize-Union{Tuple{MultiVector{CA, T, BI, K} where {T, BI, K}}, Tuple{CA}} where CA" href="#CliffordAlgebras.polarize-Union{Tuple{MultiVector{CA, T, BI, K} where {T, BI, K}}, Tuple{CA}} where CA"><code>CliffordAlgebras.polarize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polarize(mv::MultiVector)
mv&#39;</code></pre><p>Calculates the polarization of the MultiVector, i.e. mv * pseudoscalar.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/arithmetic.jl#L251-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.prune-Tuple{MultiVector}" href="#CliffordAlgebras.prune-Tuple{MultiVector}"><code>CliffordAlgebras.prune</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prune(::MultiVector ; rtol = 1e-8 )</code></pre><p>Returns a new MultiVector with all basis vectors removed from the sparse basis whose coefficients fall below the relative magnitude threshold. This function is not type stable, because the return type depends on the sparse basis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/multivector.jl#L129-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.pseudoscalar-Tuple{Type{var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:CliffordAlgebra}" href="#CliffordAlgebras.pseudoscalar-Tuple{Type{var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:CliffordAlgebra}"><code>CliffordAlgebras.pseudoscalar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pseudoscalar(::CliffordAlgebra)
pseudoscalar(::Type{&lt;:CliffordAlgebra})</code></pre><p>Returns the pseudoscalar of the given algebra.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/multivector.jl#L315-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.scalar-Union{Tuple{MultiVector{CA, T, BI, K} where K}, Tuple{BI}, Tuple{T}, Tuple{CA}} where {CA, T, BI}" href="#CliffordAlgebras.scalar-Union{Tuple{MultiVector{CA, T, BI, K} where K}, Tuple{BI}, Tuple{T}, Tuple{CA}} where {CA, T, BI}"><code>CliffordAlgebras.scalar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scalar(mv::MultiVector)</code></pre><p>Returns the scalar component of the multivector. The result if of the internal storage type eltype(mv).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/multivector.jl#L115-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.signature-Union{Tuple{Type{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:(CliffordAlgebra{Np, Nn, Nz, S, BT, MT} where {S, BT, MT})}, Tuple{Nz}, Tuple{Nn}, Tuple{Np}} where {Np, Nn, Nz}" href="#CliffordAlgebras.signature-Union{Tuple{Type{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:(CliffordAlgebra{Np, Nn, Nz, S, BT, MT} where {S, BT, MT})}, Tuple{Nz}, Tuple{Nn}, Tuple{Np}} where {Np, Nn, Nz}"><code>CliffordAlgebras.signature</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">signature(::CliffordAlgebra)
signature(::Type{&lt;:CliffordAlgebra})</code></pre><p>Returns the signature of the algebra.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/algebra.jl#L183-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.vector-Tuple{MultiVector}" href="#CliffordAlgebras.vector-Tuple{MultiVector}"><code>CliffordAlgebras.vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector(::MultiVector)</code></pre><p>Returns the non-sparse vector representation of the MutliVector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/multivector.jl#L324-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.Λᵏ-Union{Tuple{k}, Tuple{MultiVector, Val{k}}} where k" href="#CliffordAlgebras.Λᵏ-Union{Tuple{k}, Tuple{MultiVector, Val{k}}} where k"><code>CliffordAlgebras.Λᵏ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Λᵏ(::MultiVector, ::Val{k}) where k
Λᵏ(::MultiVector, k::Integer)</code></pre><p>Projects the MultiVector onto k-vectors. Similar to grade(mv,k), but uses @generated code and compile time optimizations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/arithmetic.jl#L262-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{MultiVector}" href="#LinearAlgebra.norm-Tuple{MultiVector}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">norm(::MultiVector)</code></pre><p>Calculates the MultiVector norm defined as sqrt(grade(mv*reverse(mv),0))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/arithmetic.jl#L290-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm_sqr-Tuple{MultiVector}" href="#LinearAlgebra.norm_sqr-Tuple{MultiVector}"><code>LinearAlgebra.norm_sqr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">norm_sqr(::MultiVector)</code></pre><p>Calculates the MultiVector squared norm defined as grade(mv*reverse(mv),0)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/arithmetic.jl#L297-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.CliffordAlgebra" href="#CliffordAlgebras.CliffordAlgebra"><code>CliffordAlgebras.CliffordAlgebra</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CliffordAlgebra</code></pre><p>CliffordAlgebra{Np,Nn,Nz,S} is a type that describes a geometric algebra with the signature (Np,Nn,Nz), base symbols S.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/algebra.jl#L42-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.CliffordAlgebra-Tuple{Integer, Integer, Integer}" href="#CliffordAlgebras.CliffordAlgebra-Tuple{Integer, Integer, Integer}"><code>CliffordAlgebras.CliffordAlgebra</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CliffordAlgebra(Npos::Integer, Nneg::Integer, Nzero::Integer)</code></pre><p>Generates a geometric algebra with signature (Npos,Nneg,Nzero).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/algebra.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.CliffordAlgebra-Tuple{Integer, Integer}" href="#CliffordAlgebras.CliffordAlgebra-Tuple{Integer, Integer}"><code>CliffordAlgebras.CliffordAlgebra</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CliffordAlgebra(Npos::Integer, Nneg::Integer)</code></pre><p>Generates a geometric algebra with signature (Npos,Nneg,0).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/algebra.jl#L73-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.CliffordAlgebra-Tuple{Integer}" href="#CliffordAlgebras.CliffordAlgebra-Tuple{Integer}"><code>CliffordAlgebras.CliffordAlgebra</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CliffordAlgebra(N::Integer)</code></pre><p>Generates a geometric algebra with signature (N,0,0).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/algebra.jl#L64-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.CliffordAlgebra-Tuple{Symbol}" href="#CliffordAlgebras.CliffordAlgebra-Tuple{Symbol}"><code>CliffordAlgebras.CliffordAlgebra</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CliffordAlgebra(a::Symbol)</code></pre><p>Generates a predefined algebra from a identifier. Known algebras are     - :Hyperbolic or :Hyper     - :Complex or :ℂ     - :Dual or :Grassmann     - :Quaternions or :ℍ     - :Cl2 and :Cl3     - :Spacetime     - :PGA2D or :Projective2D     - :PGA3D or :Projective3D     - :CGA2D or :Conformal2D     - :CGA3D or :Conformal3D     - :DCGA3D or :DoubleConformal3D     - :TCGA3D or :TripleConformal3D     - :DCGSTA or :DoubleConformalSpacetime     - :QCGA or :QuadricConformal</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/algebra.jl#L91-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.MultiVector" href="#CliffordAlgebras.MultiVector"><code>CliffordAlgebras.MultiVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MultiVector{CA,T,BI}</code></pre><p>Type for a multivector belonging to the algebra CA&lt;:CliffordAlgbra with vector coefficients of type T. Coefficients are stored using a sparse coding, and only the coefficients of the basis indices stored in the tuple BI are considered.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/multivector.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.MultiVector-Union{Tuple{T}, Tuple{N}, Tuple{Type{var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:CliffordAlgebra, Tuple{Vararg{T, N}}}} where {N, T&lt;:Real}" href="#CliffordAlgebras.MultiVector-Union{Tuple{T}, Tuple{N}, Tuple{Type{var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:CliffordAlgebra, Tuple{Vararg{T, N}}}} where {N, T&lt;:Real}"><code>CliffordAlgebras.MultiVector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MultiVector(::CliffordAlgebra, v::NTuple{N,T}) where {N,T&lt;:Real}
MultiVector(::Type{&lt;:CliffordAlgebra}, v::NTuple{N,T}) where {N,T&lt;:Real}</code></pre><p>Creates a MultiVector by converting the provided vector v to a 1-vector. The internal storage type of the MultiVector is T.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/multivector.jl#L35-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.MultiVector-Union{Tuple{T}, Tuple{Type{var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:CliffordAlgebra, T}} where T&lt;:Real" href="#CliffordAlgebras.MultiVector-Union{Tuple{T}, Tuple{Type{var&quot;#s16&quot;} where var&quot;#s16&quot;&lt;:CliffordAlgebra, T}} where T&lt;:Real"><code>CliffordAlgebras.MultiVector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MultiVector(::CliffordAlgebra, a::Real)
MultiVector(::Type{&lt;:CliffordAlgebra}, a::Real)</code></pre><p>Creates a MultiVector from the real number a with only a scalar component. The internal storage type of the MultiVector is the type of a.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/multivector.jl#L26-L31">source</a></section></article><p>Private symbols:</p><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.adaptbasefordual-Tuple{Any}" href="#CliffordAlgebras.adaptbasefordual-Tuple{Any}"><code>CliffordAlgebras.adaptbasefordual</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">adaptbasefordual(base)</code></pre><p>Shuffles the base vector products so that the Poincaré dual of every basis vector is another basis vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/utils.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.basegrade-Tuple{Type{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:CliffordAlgebra, Integer}" href="#CliffordAlgebras.basegrade-Tuple{Type{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:CliffordAlgebra, Integer}"><code>CliffordAlgebras.basegrade</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basegrade(::CliffordAlgebra, n::Integer)
basegrade(::Type{&lt;:CliffordAlgebra}, n::Integer)</code></pre><p>Returns the grade of the n-th basis multivector of the algebra.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/algebra.jl#L229-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.basereverse-Tuple{Type{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:CliffordAlgebra, Integer}" href="#CliffordAlgebras.basereverse-Tuple{Type{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:CliffordAlgebra, Integer}"><code>CliffordAlgebras.basereverse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basereverse(::CliffordAlgebra, n::Integer)
basereverse(::Type{&lt;:CliffordAlgebra}, n::Integer)</code></pre><p>Returns the sign change of the n-th basis multivector under reversal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/algebra.jl#L238-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.basesignature-Union{Tuple{Nz}, Tuple{Nn}, Tuple{Np}, Tuple{Type{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:(CliffordAlgebra{Np, Nn, Nz, S, BT, MT} where {S, BT, MT}), Integer}} where {Np, Nn, Nz}" href="#CliffordAlgebras.basesignature-Union{Tuple{Nz}, Tuple{Nn}, Tuple{Np}, Tuple{Type{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:(CliffordAlgebra{Np, Nn, Nz, S, BT, MT} where {S, BT, MT}), Integer}} where {Np, Nn, Nz}"><code>CliffordAlgebras.basesignature</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basesignature(::CliffordAlgebra, n::Integer)
basesignature(::Type{&lt;:CliffordAlgebra}, n::Integer)</code></pre><p>Returns the signature value of the n-th basis 1-vector. The return value is +1, -1 or 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/algebra.jl#L192-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.basesymbols-Union{Tuple{Type{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:(CliffordAlgebra{Np, Nn, Nz, S, BT, MT} where {BT, MT})}, Tuple{S}, Tuple{Nz}, Tuple{Nn}, Tuple{Np}} where {Np, Nn, Nz, S}" href="#CliffordAlgebras.basesymbols-Union{Tuple{Type{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:(CliffordAlgebra{Np, Nn, Nz, S, BT, MT} where {BT, MT})}, Tuple{S}, Tuple{Nz}, Tuple{Nn}, Tuple{Np}} where {Np, Nn, Nz, S}"><code>CliffordAlgebras.basesymbols</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basesymbols(::CliffordAlgebra)
basesymbols(::Type{&lt;:CliffordAlgebra})</code></pre><p>Returns the 1-vector space basis symbols of the algebra.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/algebra.jl#L147-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.basetable-Union{Tuple{Type{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:(CliffordAlgebra{Np, Nn, Nz, S, BT, MT} where MT)}, Tuple{BT}, Tuple{S}, Tuple{Nz}, Tuple{Nn}, Tuple{Np}} where {Np, Nn, Nz, S, BT}" href="#CliffordAlgebras.basetable-Union{Tuple{Type{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:(CliffordAlgebra{Np, Nn, Nz, S, BT, MT} where MT)}, Tuple{BT}, Tuple{S}, Tuple{Nz}, Tuple{Nn}, Tuple{Np}} where {Np, Nn, Nz, S, BT}"><code>CliffordAlgebras.basetable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">basetable(::CliffordAlgebra)
basetable(::Type{&lt;:CliffordAlgebra})</code></pre><p>Returns the internal basis table of the algebra.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/algebra.jl#L156-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.enumeratebase-Tuple{Integer}" href="#CliffordAlgebras.enumeratebase-Tuple{Integer}"><code>CliffordAlgebras.enumeratebase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">enumeratebase(N::Integer)</code></pre><p>Generates the basis vector product combinations for the Clifford algebra of an N dimensional vector space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/utils.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.findpermutation-Tuple{Any, Any}" href="#CliffordAlgebras.findpermutation-Tuple{Any, Any}"><code>CliffordAlgebras.findpermutation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findpermutation(a,b)</code></pre><p>Find the permutation that takes the a to b.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/utils.jl#L60-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.multiplicationtable-Tuple{Integer, Integer, Integer, Tuple}" href="#CliffordAlgebras.multiplicationtable-Tuple{Integer, Integer, Integer, Tuple}"><code>CliffordAlgebras.multiplicationtable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">multiplicationstable(Npos::Integer, Nneg::Integer, Nzero::Integer, base::Tuple)</code></pre><p>Generates a multiplication table for the Clifford algebra with the specified signature and base vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/algebra.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.multtable-Union{Tuple{Type{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:CliffordAlgebra{Np, Nn, Nz, S, BT, MT}}, Tuple{MT}, Tuple{BT}, Tuple{S}, Tuple{Nz}, Tuple{Nn}, Tuple{Np}} where {Np, Nn, Nz, S, BT, MT}" href="#CliffordAlgebras.multtable-Union{Tuple{Type{var&quot;#s10&quot;} where var&quot;#s10&quot;&lt;:CliffordAlgebra{Np, Nn, Nz, S, BT, MT}}, Tuple{MT}, Tuple{BT}, Tuple{S}, Tuple{Nz}, Tuple{Nn}, Tuple{Np}} where {Np, Nn, Nz, S, BT, MT}"><code>CliffordAlgebras.multtable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">multtable(::CliffordAlgebra)
multtable(::Type{&lt;:CliffordAlgebra})</code></pre><p>Returns the internal multuplication table of the geometric product of the algebra.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/algebra.jl#L165-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CliffordAlgebras.nextselector-Union{Tuple{N}, Tuple{Tuple{Vararg{var&quot;#s3&quot;, N}} where var&quot;#s3&quot;&lt;:Integer, Any}} where N" href="#CliffordAlgebras.nextselector-Union{Tuple{N}, Tuple{Tuple{Vararg{var&quot;#s3&quot;, N}} where var&quot;#s3&quot;&lt;:Integer, Any}} where N"><code>CliffordAlgebras.nextselector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nextselector(s::NTuple{N,&lt;:Integer},M) where N</code></pre><p>Helper function for enumerating base vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ATell-SoundTheory/CliffordAlgebras.jl/blob/fba7922effab44c7b6cce08b5c03abb8b114a308/src/utils.jl#L3-L7">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Tuesday 23 November 2021 15:39">Tuesday 23 November 2021</span>. Using Julia version 1.6.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
